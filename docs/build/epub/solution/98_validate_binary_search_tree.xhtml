<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>98_validate_binary_search_tree</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/epub.css" type="text/css" /> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-src.solution.98_validate_binary_search_tree">
<span id="validate-binary-search-tree"></span><h1>98_validate_binary_search_tree</h1>
<div class="section" id="id1">
<h2><a class="reference external" href="https:leetcode-cn.com/problems/validate-binary-search-tree/">Problem</a><span class="link-target"> [https:leetcode-cn.com/problems/validate-binary-search-tree/]</span></h2>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul class="simple">
<li><p>节点的左子树只包含小于当前节点的数。</p></li>
<li><p>节点的右子树只包含大于当前节点的数。</p></li>
<li><p>所有左子树和右子树自身必须也是二叉搜索树。</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>示例 1:
输入:
  2
 / \
1   3
输出: true

示例 2:
输入:
  5
 / \
1   4
   / \
  3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
    根节点的值为 5 ，但是其右子节点值为 4 。
</pre></div>
</div>
</div>
<div class="section" id="tips">
<h2>Tips</h2>
<p>方法一 中序遍历:</p>
<p>使用中序遍历的顺序是树节点的投影性质。存储一个 <code class="docutils literal notranslate"><span class="pre">prev</span></code> 节点，每次访问节点的时候比较 <code class="docutils literal notranslate"><span class="pre">prev</span> <span class="pre">&lt;</span> <span class="pre">curnode</span></code> 。
如果不是单调递增，则不符合二叉搜索树的定义。即可返回结果</p>
<p>方法二 DFS递归：</p>
<p>根据二叉树搜索树的定义，<code class="docutils literal notranslate"><span class="pre">左边的节点</span> <span class="pre">&lt;</span> <span class="pre">当前节点</span> <span class="pre">&lt;</span> <span class="pre">右边的节点</span></code> 左边的节点可能是左孩子，也可能是左孩子的右孩子</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   <span class="mi">10</span>
  <span class="o">/</span>
<span class="mi">5</span>
 \
  <span class="mi">8</span>
</pre></div>
</div>
<p>因此每次递归的时候，需要传入一个下界（左边最大值）和一个上界（右边最小值）。使用 DFS 递归遍历即可。伪代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">lval</span><span class="p">,</span> <span class="n">rval</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="c1"># 空树属于二叉搜索树</span>
    <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># 当前节点在 (lval, rval) 区间内，递归左右子树</span>
    <span class="k">if</span> <span class="n">lval</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">rval</span><span class="p">:</span>
        <span class="c1"># 递归左子树，当前节点为左子树的上界。</span>
        <span class="n">lvalid</span> <span class="o">=</span>  <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">lval</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="c1"># 递归右子树，当前节点为右子树的下界。</span>
        <span class="n">rvalid</span> <span class="o">=</span>  <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">rval</span><span class="p">)</span>
        <span class="c1"># 左右子树都是二叉搜索树</span>
        <span class="k">return</span> <span class="n">lvalid</span> <span class="ow">and</span> <span class="n">rvalid</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># 当前节点不在 (lval, rval) 区间内，不符合二叉搜索树定义，返回 False</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
<p>dfs 方法中，通常可以使用 <code class="docutils literal notranslate"><span class="pre">and</span></code> 或 <code class="docutils literal notranslate"><span class="pre">or</span></code> 逻辑表达式通过短路提前返回，优化性能 <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">dfs(node.left)</span> <span class="pre">and</span> <span class="pre">dfs(node.right)</span></code></p>
</div>
<div class="section" id="answer">
<h2>Answer</h2>
<dl class="py class">
<dt id="src.solution.98_validate_binary_search_tree.Solution">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">src.solution.98_validate_binary_search_tree.</span></code><code class="sig-name descname"><span class="pre">Solution</span></code></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a><span class="link-target"> [https://docs.python.org/3/library/functions.html#object]</span></p>
<dl class="py method">
<dt id="src.solution.98_validate_binary_search_tree.Solution.dfs">
<code class="sig-name descname"><span class="pre">dfs</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><a class="reference internal" href="../datastruct/bin_treenode.xhtml#src.datastruct.bin_treenode.TreeNode" title="src.datastruct.bin_treenode.TreeNode"><span class="pre">src.datastruct.bin_treenode.TreeNode</span></a></span></em><span class="sig-paren">)</span> &#x2192; <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><span class="pre">bool</span></a><span class="link-target"> <span class="pre">[https://docs.python.org/3/library/functions.html#bool]</span></span></dt>
<dd><p>dfs 递归遍历</p>
</dd></dl>

<dl class="py method">
<dt id="src.solution.98_validate_binary_search_tree.Solution.inorder">
<code class="sig-name descname"><span class="pre">inorder</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><a class="reference internal" href="../datastruct/bin_treenode.xhtml#src.datastruct.bin_treenode.TreeNode" title="src.datastruct.bin_treenode.TreeNode"><span class="pre">src.datastruct.bin_treenode.TreeNode</span></a></span></em><span class="sig-paren">)</span> &#x2192; <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><span class="pre">bool</span></a><span class="link-target"> <span class="pre">[https://docs.python.org/3/library/functions.html#bool]</span></span></dt>
<dd><p>中序遍历</p>
</dd></dl>

<dl class="py method">
<dt id="src.solution.98_validate_binary_search_tree.Solution.isValidBST">
<code class="sig-name descname"><span class="pre">isValidBST</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><a class="reference internal" href="../datastruct/bin_treenode.xhtml#src.datastruct.bin_treenode.TreeNode" title="src.datastruct.bin_treenode.TreeNode"><span class="pre">src.datastruct.bin_treenode.TreeNode</span></a></span></em><span class="sig-paren">)</span> &#x2192; <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><span class="pre">bool</span></a><span class="link-target"> <span class="pre">[https://docs.python.org/3/library/functions.html#bool]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="src.solution.98_validate_binary_search_tree.TestSolution">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">src.solution.98_validate_binary_search_tree.</span></code><code class="sig-name descname"><span class="pre">TestSolution</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">methodName</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'runTest'</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.case.TestCase</span></code></p>
<dl class="py method">
<dt id="src.solution.98_validate_binary_search_tree.TestSolution.setUp">
<code class="sig-name descname"><span class="pre">setUp</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Hook method for setting up the test fixture before exercising it.</p>
</dd></dl>

<dl class="py method">
<dt id="src.solution.98_validate_binary_search_tree.TestSolution.test_solution">
<code class="sig-name descname"><span class="pre">test_solution</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>